---
title: "MP_agents"
author: "EOL"
date: "2024-02-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Mathcing Pennies Game

This markdown contains the code for the simulation two different strategies of the matching pennies game. The game is a simple two-player game where each player has to choose between two options (right or left). The winner is determined by whether the choices match or not.

## Strategy 1: Noisy Win-Stay-Lose-Shift Agent (periodically random behaviour)
`WSLSAgentNoise_f` is a function for an agent that, as baseline, follows the `WSLS`strategy. 
But the agent sometimes gets distracted or for other reasons periodically makes mistakes, so in each trial there is a chance (dependent on the `noise` parameter) 
that any choice will be random rather than adhering to the WSLS strategy.  

```{r WSLS Agent function with noise}

WSLSAgentNoise_f <- function(prevChoice, Feedback,noise) {
    # randomness (depends on noise parameter)
    if (rbinom(1, 1, noise) == 1) { 
    choice <- rbinom(1, 1, 0.5) # if noise, choose randomly
    
    # if no noise, adhere to WSLS strategy
  } else {
    if (Feedback == 1) {
      choice = prevChoice
    } else if (Feedback == 0) {
      choice = 1 - prevChoice
    }
  }
  return(choice)
}
```

## Exponential Decay Agent

An agent that will decay its memory of previous choices over time.
It has a memory of previoys choices and a decay parameter.
Moreover, it keeps track of what choices are related to success using 
some weight parameter and makes a choice in a given trial based on the highest weight. 

Moreover, it has a 10% chance of choosing randomly, reflecting mistakes/noise. 

```{r alternative memory decay agent that uses weights}

MemoryDecayAgentWeight_f <- function(prevChoices, Feedback, decay, noise) {
  n <- length(prevChoices)

  if (rbinom(1, 1, noise) == 1) {
    choice <- rbinom(1, 1, 0.5) # if noise, choose randomly
  } else {
    decay_factor <- exp(-decay)
    prevChoices <- decay_factor * prevChoices

    # Calculate the exponentially decaying weights for each feedback
    weights <- exp(-decay * (1:n)) # small values for small values of n
    
    # Calculate the weighted proportion of positive feedbacks
    weighted_proportions <- cumsum(Feedback * weights) / cumsum(weights)
    
    # Choose the option with the highest weighted proportion
    choice <- ifelse(weighted_proportions[n] > 0.5, 1, 0)

    prevChoices <- c(prevChoices, choice)
  }

  # Return the updated choice and memory state
  return(list(choice = choice, memory = prevChoices))
}
```


## Simulate a game between the noisy WSLS agent and memory decay agent 
```{r}

set.seed(1984)
trials <- 120

# vectors to store choices
self_noise_WSLS <- rep(NA, trials)
other_decay <- rep(NA, trials)

self_feedback <- rep(NA, trials)
other_feedback <- rep(NA, trials)

# initialising the first choices randomly 
self_noise_WSLS[1] <- rbinom(1,1,0.5)
other_decay_choices <- rbinom(1,1,0.5)
other_decay[1] <- other_decay_choices


# Simulating interactions between noise Win-Stay-Lose-Shift Agent and Memory Decay Agent
for (i in 2:trials) {
  # Get feedback based on previous choices
  Feedback_noise_WSLS <- as.numeric(self_noise_WSLS[i - 1] == other_decay[i - 1])
  Feedback_decay <- 1 - Feedback_noise_WSLS

  # Storing feedback
  self_feedback[i - 1] <- Feedback_noise_WSLS
  other_feedback[i - 1] <- Feedback_decay
  
  # Making choices for the next trial
  self_noise_WSLS[i] <- WSLSAgentNoise_f(self_noise_WSLS[i - 1], Feedback_noise_WSLS, 0.2)
  
  # For the Memory Decay agent, we are passing the cumulative vector rather than just the last feedback
  other_decay_decision <- MemoryDecayAgentWeight_f(other_decay_choices, other_feedback[1:(i-1)], 0.1, 0.1)
  other_decay_choices <- other_decay_decision$memory
  other_decay[i] <- other_decay_decision$choice
}

# Creating a data frame for visualization
pacman::p_load(tidyverse)

df2 <- tibble(
  trial = seq(trials),
  self_noise_WSLS = self_noise_WSLS,
  other_decay = other_decay,
  Feedback_noise_WSLS = self_feedback
)
```


```{r Visualise results}
# Visualize the results
library(ggplot2)

# Visualizing the results
pl1 <- ggplot(df2, aes(trial)) +
  geom_line(aes(y = self_noise_WSLS, color = "Noisy WSLS Agent"), size = 1) +
  geom_line(aes(y = other_decay, color = "Memory Decay Agent"), size = 1) +
  labs(title = "Noisy WSLS Agent vs. Memory Decay Agent",
       y = "Choice", x = "Trial") +
  scale_color_manual(name = "Agents", values = c("Noisy WSLS Agent" = "red", "Memory Decay Agent" = "blue")) +
  theme_classic()

# Calculate and plot the cumulative win rate for each agent
df2$cumulativeWinRateSelf <- cumsum(df2$Feedback_noise_WSLS) / seq_along(df2$Feedback_noise_WSLS)
df2$cumulativeWinRateOther <- (seq_along(df2$Feedback_noise_WSLS) - cumsum(df2$Feedback_noise_WSLS)) / seq_along(df2$Feedback_noise_WSLS)

pl2 <- ggplot(df2, aes(trial)) +
  geom_line(aes(y = cumulativeWinRateSelf, color = "Noisy WSLS Agent"), size = 1) +
  geom_line(aes(y = cumulativeWinRateOther, color = "Memory Decay Agent"), size = 1) +
  labs(title = "Cumulative Win Rate of Noisy WSLS Agent vs. Memory Decay Agent",
       y = "Cumulative Win Rate", x = "Trial") +
  scale_color_manual(name = "Agents", values = c("Noisy WSLS Agent" = "red", "Memory Decay Agent" = "blue")) +
  theme_classic()

# Displaying the plots together
final_plt <- gridExtra::grid.arrange(pl1, pl2, ncol = 1)

# save the plot to drive
ggsave("figs/MP_agents.png", final_plt, width = 10, height = 10, units = "in")
```


## Comparing each of the strategies to a random agent as baseline

```{r}
RandomAgent_f <- function(input, rate){
  n <- length(input)
  choice <- rbinom(n, 1, rate)
  return(choice)
}
```

```{r random vs WSLS}

# simulate a game between the noisy WSLS agent and the random agent
set.seed(1984)
trials <- 120

# vectors to store choices
self_noise_WSLS <- rep(NA, trials)
other_random <- rep(NA, trials)

self_feedback <- rep(NA, trials)
other_feedback <- rep(NA, trials)

# initialising the first choices randomly 
self_noise_WSLS[1] <- rbinom(1,1,0.5)
other_random_choices <- RandomAgent_f(1, 0.5)  # starting with a random choice for the random agent
other_random[1] <- other_random_choices

# simulating interactions between noisy Win-Stay-Lose-Shift Agent and Random Agent
for (i in 2:trials) {
  # get feedback based on previous choices
  Feedback_noise_WSLS <- as.numeric(self_noise_WSLS[i - 1] == other_random[i - 1])
  Feedback_random <- 1 - Feedback_noise_WSLS

  # storing feedback
  self_feedback[i - 1] <- Feedback_noise_WSLS
  other_feedback[i - 1] <- Feedback_random
  
  # making choices for the next trial
  self_noise_WSLS[i] <- WSLSAgentNoise_f(self_noise_WSLS[i - 1], Feedback_noise_WSLS, 0.2)
  other_random_choices <- RandomAgent_f(other_random_choices, 0.5)
  other_random[i] <- other_random_choices
}

# creating a data frame for visualization
df_random_vs_WSLS <- tibble(
  trial = seq(trials),
  self_noise_WSLS = self_noise_WSLS,
  other_random = other_random,
  Feedback_noise_WSLS = self_feedback
)

# visualizing the results
pl_random_vs_WSLS <- ggplot(df_random_vs_WSLS, aes(trial)) +
  geom_line(aes(y = self_noise_WSLS, color = "Noisy WSLS Agent"), size = 1) +
  geom_line(aes(y = other_random, color = "Random Agent"), size = 1) +
  labs(title = "Noisy WSLS Agent vs. Random Agent",
       y = "Choice", x = "Trial") +
  scale_color_manual(name = "Agents", values = c("Noisy WSLS Agent" = "red", "Random Agent" = "blue")) +
  theme_classic()

# calculate and plot the cumulative win rate for each agent
df_random_vs_WSLS$cumulativeWinRateSelf <- cumsum(df_random_vs_WSLS$Feedback_noise_WSLS) / seq_along(df_random_vs_WSLS$Feedback_noise_WSLS)
df_random_vs_WSLS$cumulativeWinRateOther <- (seq_along(df_random_vs_WSLS$Feedback_noise_WSLS) - cumsum(df_random_vs_WSLS$Feedback_noise_WSLS)) / seq_along(df_random_vs_WSLS$Feedback_noise_WSLS)

pl2_random_vs_WSLS <- ggplot(df_random_vs_WSLS, aes(trial)) +
  geom_line(aes(y = cumulativeWinRateSelf, color = "Noisy WSLS Agent"), size = 1) +
  geom_line(aes(y = cumulativeWinRateOther, color = "Random Agent"), size = 1) +
  labs(title = "Cumulative Win Rate of Noisy WSLS Agent vs. Random Agent",
       y = "Cumulative Win Rate", x = "Trial") +
  scale_color_manual(name = "Agents", values = c("Noisy WSLS Agent" = "red", "Random Agent" = "blue")) +
  theme_classic()

# displaying the plots together
final_plt_random_vs_WSLS <- gridExtra::grid.arrange(pl_random_vs_WSLS, pl2_random_vs_WSLS, ncol = 1)

# save the plot 
ggsave("figs/Noisy_WSLS_vs_Random.png", final_plt_random_vs_WSLS, width = 10, height = 10, units = "in")

```

```{r random vs memory decay agent}

# Simulate a game between the Memory Decay agent and the random agent
set.seed(1984)
trials <- 120

# vectors to store choices
self_memory_decay <- rep(NA, trials)
other_random <- rep(NA, trials)

self_feedback <- rep(NA, trials)
other_feedback <- rep(NA, trials)

# initialising the first choices randomly 
self_memory_decay[1] <- rbinom(1, 1, 0.5)
other_random_choices <- RandomAgent_f(1, 0.5)  # Starting with a random choice for the random agent
other_random[1] <- other_random_choices

# Simulating interactions between Memory Decay Agent and Random Agent
for (i in 2:trials) {
  # Get feedback based on previous choices
  Feedback_memory_decay <- as.numeric(self_memory_decay[i - 1] == other_random[i - 1])
  Feedback_random <- 1 - Feedback_memory_decay

  # Storing feedback
  self_feedback[i - 1] <- Feedback_memory_decay
  other_feedback[i - 1] <- Feedback_random
  
  # Making choices for the next trial
  memory_decay_decision <- MemoryDecayAgentWeight_f(self_memory_decay, other_feedback[1:(i-1)], 0.1, 0.1)
  self_memory_decay[i] <- memory_decay_decision$choice
  other_random_choices <- RandomAgent_f(other_random_choices, 0.5)
  other_random[i] <- other_random_choices
}

# Creating a data frame for visualization
df_memory_decay_vs_random <- tibble(
  trial = seq(trials),
  self_memory_decay = self_memory_decay,
  other_random = other_random,
  Feedback_memory_decay = self_feedback
)

# Visualizing the results
pl_memory_decay_vs_random <- ggplot(df_memory_decay_vs_random, aes(trial)) +
  geom_line(aes(y = self_memory_decay, color = "Memory Decay Agent"), size = 1) +
  geom_line(aes(y = other_random, color = "Random Agent"), size = 1) +
  labs(title = "Memory Decay Agent vs. Random Agent",
       y = "Choice", x = "Trial") +
  scale_color_manual(name = "Agents", values = c("Memory Decay Agent" = "blue", "Random Agent" = "green")) +
  theme_classic()

# Calculate and plot the cumulative win rate for each agent
df_memory_decay_vs_random$cumulativeWinRateSelf <- cumsum(df_memory_decay_vs_random$Feedback_memory_decay) / seq_along(df_memory_decay_vs_random$Feedback_memory_decay)
df_memory_decay_vs_random$cumulativeWinRateOther <- (seq_along(df_memory_decay_vs_random$Feedback_memory_decay) - cumsum(df_memory_decay_vs_random$Feedback_memory_decay)) / seq_along(df_memory_decay_vs_random$Feedback_memory_decay)

pl2_memory_decay_vs_random <- ggplot(df_memory_decay_vs_random, aes(trial)) +
  geom_line(aes(y = cumulativeWinRateSelf, color = "Memory Decay Agent"), size = 1) +
  geom_line(aes(y = cumulativeWinRateOther, color = "Random Agent"), size = 1) +
  labs(title = "Cumulative Win Rate of Memory Decay Agent vs. Random Agent",
       y = "Cumulative Win Rate", x = "Trial") +
  scale_color_manual(name = "Agents", values = c("Memory Decay Agent" = "blue", "Random Agent" = "green")) +
  theme_classic()

# Displaying the plots together
final_plt_memory_decay_vs_random <- gridExtra::grid.arrange(pl_memory_decay_vs_random, pl2_memory_decay_vs_random, ncol = 1)

# save the plot to drive
ggsave("figs/Memory_Decay_vs_Random.png", final_plt_memory_decay_vs_random, width = 10, height = 10, units = "in")
```

```{r}
baseline_plots <- gridExtra::grid.arrange(pl2_random_vs_WSLS, pl2_memory_decay_vs_random, ncol = 1)
baseline_plots

ggsave("figs/baseline_plots.png", baseline_plots, width = 15, height = 10, units = "in")
```


